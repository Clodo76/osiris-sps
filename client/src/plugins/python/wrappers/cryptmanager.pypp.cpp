// This file has been generated by Py++.

#include "stdafx.h"
#include "pypluspluscommon.h"
#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "cryptmanager.h"
#include "cryptkey.h"
#include "cryptmanager.pypp.hpp"

namespace bp = boost::python;

struct CryptManager_wrapper : ::osiris::CryptManager, ::osiris::PythonWrapper< ::osiris::CryptManager > {

    CryptManager_wrapper( )
    : ::osiris::CryptManager( )
      , ::osiris::PythonWrapper< ::osiris::CryptManager >(){
        // nullptr constructor
    
    }

    static boost::python::object getRandomPool( ::osiris::CryptManager const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::LockPtr<CryptoPP::AutoSeededRandomPool,boost::recursive_mutex,boost::unique_lock<boost::recursive_mutex> > result = inst.getRandomPool();
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object CRC32( ::osiris::CryptManager const & inst, void const * data, ::size_t size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::uint32 result = inst.CRC32(data, size);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object MD5( ::osiris::CryptManager const & inst, void const * data, ::size_t size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::Buffer result = inst.MD5(data, size);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object SHA( ::osiris::CryptManager const & inst, void const * data, ::size_t size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::Buffer result = inst.SHA(data, size);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object SHA256( ::osiris::CryptManager const & inst, void const * data, ::size_t size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::Buffer result = inst.SHA256(data, size);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object SHA512( ::osiris::CryptManager const & inst, void const * data, ::size_t size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::Buffer result = inst.SHA512(data, size);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object randomMD5( ::osiris::CryptManager const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::Buffer result = inst.randomMD5();
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object randomSHA( ::osiris::CryptManager const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::Buffer result = inst.randomSHA();
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object aesEncrypt( ::osiris::CryptManager & inst, ::osiris::CryptKey const & key, void const * data, ::size_t size, ::osiris::Buffer & encrypted, bool saveHeader=true ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.aesEncrypt(key, data, size, encrypted, saveHeader);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object aesDecrypt( ::osiris::CryptManager & inst, ::osiris::CryptKey const & key, void const * data, ::size_t size, ::osiris::Buffer & decrypted, bool loadHeader=true ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.aesDecrypt(key, data, size, decrypted, loadHeader);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rsaGenerateKeys( ::osiris::CryptManager & inst, ::osiris::RsaType type, ::osiris::Buffer & privateKey, ::osiris::Buffer & publicKey ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rsaGenerateKeys(type, privateKey, publicKey);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rsaGetPublicKey( ::osiris::CryptManager & inst, ::osiris::Buffer const & privateKey, ::osiris::Buffer & publicKey ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rsaGetPublicKey(privateKey, publicKey);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rsaEncrypt( ::osiris::CryptManager & inst, ::osiris::Buffer const & public_key, void const * data, ::size_t size, ::osiris::Buffer & encrypted ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rsaEncrypt(public_key, data, size, encrypted);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rsaDecrypt( ::osiris::CryptManager & inst, ::osiris::Buffer const & private_key, void const * data, ::size_t size, ::osiris::Buffer & decrypted ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rsaDecrypt(private_key, data, size, decrypted);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rrsaEncrypt( ::osiris::CryptManager & inst, ::osiris::Buffer const & private_key, void const * data, ::size_t size, ::osiris::Buffer & encrypted ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rrsaEncrypt(private_key, data, size, encrypted);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rrsaDecrypt( ::osiris::CryptManager & inst, ::osiris::Buffer const & public_key, void const * data, ::size_t size, ::osiris::Buffer & decrypted ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rrsaDecrypt(public_key, data, size, decrypted);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rsaSign( ::osiris::CryptManager & inst, ::osiris::Buffer const & private_key, void const * data, ::size_t size, ::osiris::Buffer & signature ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rsaSign(private_key, data, size, signature);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rsaVerify( ::osiris::CryptManager & inst, ::osiris::Buffer const & public_key, void const * data, ::size_t size, ::osiris::Buffer const & signature ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rsaVerify(public_key, data, size, signature);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object rsaCheckKeys( ::osiris::CryptManager & inst, ::osiris::Buffer const & privateKey, ::osiris::Buffer const & publicKey ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.rsaCheckKeys(privateKey, publicKey);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object detectCompressor_fa6db49a19c136218c84537212780469( ::osiris::CryptManager & inst, void const * data, ::size_t size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::CompressorType result = inst.detectCompressor(data, size);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object matchCompressor_00307e534961602902013b865108f3ec( ::osiris::CryptManager & inst, void const * data, ::size_t size, ::osiris::CompressorType compressor ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.matchCompressor(data, size, compressor);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object matchCompressor_17679b85441fbba8d2bab80856f76c29( ::osiris::CryptManager & inst, ::boost::shared_ptr< osiris::IStream > stream, ::osiris::CompressorType compressor ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.matchCompressor(stream, compressor);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object compress( ::osiris::CryptManager & inst, ::osiris::CompressorType compressor, void const * data, ::size_t size, ::osiris::Buffer & compressed, ::osiris::CompressionLevel level=(::osiris::compressionLevelHigh) ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.compress(compressor, data, size, compressed, level);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object decompress( ::osiris::CryptManager & inst, ::osiris::CompressorType decompressor, void const * data, ::size_t size, ::osiris::Buffer & decompressed ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.decompress(decompressor, data, size, decompressed);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object encodeBase64_f9218abbac278d5cd6937915e06bd355( ::osiris::CryptManager & inst, void const * data, ::size_t size, ::osiris::String & encoded ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.encodeBase64(data, size, encoded);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object encodeBase64_38ee4184ffeb0a19a7589a170ccc1d42( ::osiris::CryptManager & inst, void const * data, ::size_t size, ::std::string & encoded ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.encodeBase64(data, size, encoded);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object decodeBase64( ::osiris::CryptManager & inst, ::std::string const & input, ::osiris::Buffer & output ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.decodeBase64(input, output);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object encodeHex_7b8750fe1349c168dd19acc78f4097a9( ::osiris::CryptManager & inst, void const * data, ::size_t size, ::osiris::String & encoded ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.encodeHex(data, size, encoded);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object encodeHex_58e8799e61ba13989814002e9750ba61( ::osiris::CryptManager & inst, void const * data, ::size_t size, ::std::string & encoded ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.encodeHex(data, size, encoded);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object decodeHex( ::osiris::CryptManager & inst, ::std::string const & encoded, ::osiris::Buffer & decoded ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.decodeHex(encoded, decoded);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static void randomBlock( ::osiris::CryptManager const & inst, void * data, ::size_t size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        inst.randomBlock(data, size);
        __pythreadSaver.restore();
    }

    static boost::python::object detectCompressor_5ce6eb82fa1ac7c37571973dbaba8ee7( ::osiris::CryptManager & inst, ::boost::shared_ptr< osiris::IStream > stream ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::CompressorType result = inst.detectCompressor(stream);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

};

void register_CryptManager_class(){

    { //::osiris::CryptManager
        typedef ::boost::python::class_< CryptManager_wrapper, ::boost::python::bases< ::osiris::StaticSingleton< osiris::CryptManager, true > >, ::boost::noncopyable > CryptManager_exposer_t;
        CryptManager_exposer_t CryptManager_exposer = CryptManager_exposer_t( "CryptManager", ::boost::python::no_init );
        ::boost::python::scope CryptManager_scope( CryptManager_exposer );
        CryptManager_exposer.def( ::boost::python::init< >() );
        { //::osiris::CryptManager::getRandomPool
        
            typedef boost::python::object ( *getRandomPool_function_type )( ::osiris::CryptManager const & );
            
            CryptManager_exposer.def( 
                "getRandomPool"
                , getRandomPool_function_type( &CryptManager_wrapper::getRandomPool ) );
        
        }
        { //::osiris::CryptManager::CRC32
        
            typedef boost::python::object ( *CRC32_function_type )( ::osiris::CryptManager const &,void const *,::size_t );
            
            CryptManager_exposer.def( 
                "CRC32"
                , CRC32_function_type( &CryptManager_wrapper::CRC32 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::CryptManager::MD5
        
            typedef boost::python::object ( *MD5_function_type )( ::osiris::CryptManager const &,void const *,::size_t );
            
            CryptManager_exposer.def( 
                "MD5"
                , MD5_function_type( &CryptManager_wrapper::MD5 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::CryptManager::SHA
        
            typedef boost::python::object ( *SHA_function_type )( ::osiris::CryptManager const &,void const *,::size_t );
            
            CryptManager_exposer.def( 
                "SHA"
                , SHA_function_type( &CryptManager_wrapper::SHA )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::CryptManager::SHA256
        
            typedef boost::python::object ( *SHA256_function_type )( ::osiris::CryptManager const &,void const *,::size_t );
            
            CryptManager_exposer.def( 
                "SHA256"
                , SHA256_function_type( &CryptManager_wrapper::SHA256 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::CryptManager::SHA512
        
            typedef boost::python::object ( *SHA512_function_type )( ::osiris::CryptManager const &,void const *,::size_t );
            
            CryptManager_exposer.def( 
                "SHA512"
                , SHA512_function_type( &CryptManager_wrapper::SHA512 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::CryptManager::randomMD5
        
            typedef boost::python::object ( *randomMD5_function_type )( ::osiris::CryptManager const & );
            
            CryptManager_exposer.def( 
                "randomMD5"
                , randomMD5_function_type( &CryptManager_wrapper::randomMD5 ) );
        
        }
        { //::osiris::CryptManager::randomSHA
        
            typedef boost::python::object ( *randomSHA_function_type )( ::osiris::CryptManager const & );
            
            CryptManager_exposer.def( 
                "randomSHA"
                , randomSHA_function_type( &CryptManager_wrapper::randomSHA ) );
        
        }
        { //::osiris::CryptManager::aesEncrypt
        
            typedef boost::python::object ( *aesEncrypt_function_type )( ::osiris::CryptManager &,::osiris::CryptKey const &,void const *,::size_t,::osiris::Buffer &,bool );
            
            CryptManager_exposer.def( 
                "aesEncrypt"
                , aesEncrypt_function_type( &CryptManager_wrapper::aesEncrypt )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("encrypted"), ::boost::python::arg("saveHeader")=(bool)(true) ) );
        
        }
        { //::osiris::CryptManager::aesDecrypt
        
            typedef boost::python::object ( *aesDecrypt_function_type )( ::osiris::CryptManager &,::osiris::CryptKey const &,void const *,::size_t,::osiris::Buffer &,bool );
            
            CryptManager_exposer.def( 
                "aesDecrypt"
                , aesDecrypt_function_type( &CryptManager_wrapper::aesDecrypt )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("decrypted"), ::boost::python::arg("loadHeader")=(bool)(true) ) );
        
        }
        { //::osiris::CryptManager::rsaGenerateKeys
        
            typedef boost::python::object ( *rsaGenerateKeys_function_type )( ::osiris::CryptManager &,::osiris::RsaType,::osiris::Buffer &,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "rsaGenerateKeys"
                , rsaGenerateKeys_function_type( &CryptManager_wrapper::rsaGenerateKeys )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("type"), ::boost::python::arg("privateKey"), ::boost::python::arg("publicKey") ) );
        
        }
        { //::osiris::CryptManager::rsaGetPublicKey
        
            typedef boost::python::object ( *rsaGetPublicKey_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "rsaGetPublicKey"
                , rsaGetPublicKey_function_type( &CryptManager_wrapper::rsaGetPublicKey )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("privateKey"), ::boost::python::arg("publicKey") ) );
        
        }
        { //::osiris::CryptManager::rsaEncrypt
        
            typedef boost::python::object ( *rsaEncrypt_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,void const *,::size_t,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "rsaEncrypt"
                , rsaEncrypt_function_type( &CryptManager_wrapper::rsaEncrypt )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("public_key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("encrypted") ) );
        
        }
        { //::osiris::CryptManager::rsaDecrypt
        
            typedef boost::python::object ( *rsaDecrypt_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,void const *,::size_t,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "rsaDecrypt"
                , rsaDecrypt_function_type( &CryptManager_wrapper::rsaDecrypt )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("private_key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("decrypted") ) );
        
        }
        { //::osiris::CryptManager::rrsaEncrypt
        
            typedef boost::python::object ( *rrsaEncrypt_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,void const *,::size_t,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "rrsaEncrypt"
                , rrsaEncrypt_function_type( &CryptManager_wrapper::rrsaEncrypt )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("private_key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("encrypted") ) );
        
        }
        { //::osiris::CryptManager::rrsaDecrypt
        
            typedef boost::python::object ( *rrsaDecrypt_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,void const *,::size_t,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "rrsaDecrypt"
                , rrsaDecrypt_function_type( &CryptManager_wrapper::rrsaDecrypt )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("public_key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("decrypted") ) );
        
        }
        { //::osiris::CryptManager::rsaSign
        
            typedef boost::python::object ( *rsaSign_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,void const *,::size_t,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "rsaSign"
                , rsaSign_function_type( &CryptManager_wrapper::rsaSign )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("private_key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("signature") ) );
        
        }
        { //::osiris::CryptManager::rsaVerify
        
            typedef boost::python::object ( *rsaVerify_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,void const *,::size_t,::osiris::Buffer const & );
            
            CryptManager_exposer.def( 
                "rsaVerify"
                , rsaVerify_function_type( &CryptManager_wrapper::rsaVerify )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("public_key"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("signature") ) );
        
        }
        { //::osiris::CryptManager::rsaCheckKeys
        
            typedef boost::python::object ( *rsaCheckKeys_function_type )( ::osiris::CryptManager &,::osiris::Buffer const &,::osiris::Buffer const & );
            
            CryptManager_exposer.def( 
                "rsaCheckKeys"
                , rsaCheckKeys_function_type( &CryptManager_wrapper::rsaCheckKeys )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("privateKey"), ::boost::python::arg("publicKey") ) );
        
        }
        { //::osiris::CryptManager::detectCompressor
        
            typedef boost::python::object ( *detectCompressor_function_type )( ::osiris::CryptManager &,void const *,::size_t );
            
            CryptManager_exposer.def( 
                "detectCompressor"
                , detectCompressor_function_type( &CryptManager_wrapper::detectCompressor_fa6db49a19c136218c84537212780469 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::CryptManager::matchCompressor
        
            typedef boost::python::object ( *matchCompressor_function_type )( ::osiris::CryptManager &,void const *,::size_t,::osiris::CompressorType );
            
            CryptManager_exposer.def( 
                "matchCompressor"
                , matchCompressor_function_type( &CryptManager_wrapper::matchCompressor_00307e534961602902013b865108f3ec )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("compressor") ) );
        
        }
        { //::osiris::CryptManager::matchCompressor
        
            typedef boost::python::object ( *matchCompressor_function_type )( ::osiris::CryptManager &,::boost::shared_ptr<osiris::IStream>,::osiris::CompressorType );
            
            CryptManager_exposer.def( 
                "matchCompressor"
                , matchCompressor_function_type( &CryptManager_wrapper::matchCompressor_17679b85441fbba8d2bab80856f76c29 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("stream"), ::boost::python::arg("compressor") ) );
        
        }
        { //::osiris::CryptManager::compress
        
            typedef boost::python::object ( *compress_function_type )( ::osiris::CryptManager &,::osiris::CompressorType,void const *,::size_t,::osiris::Buffer &,::osiris::CompressionLevel );
            
            CryptManager_exposer.def( 
                "compress"
                , compress_function_type( &CryptManager_wrapper::compress )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("compressor"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("compressed"), ::boost::python::arg("level")=(::osiris::compressionLevelHigh) ) );
        
        }
        { //::osiris::CryptManager::decompress
        
            typedef boost::python::object ( *decompress_function_type )( ::osiris::CryptManager &,::osiris::CompressorType,void const *,::size_t,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "decompress"
                , decompress_function_type( &CryptManager_wrapper::decompress )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("decompressor"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("decompressed") ) );
        
        }
        { //::osiris::CryptManager::encodeBase64
        
            typedef boost::python::object ( *encodeBase64_function_type )( ::osiris::CryptManager &,void const *,::size_t,::osiris::String & );
            
            CryptManager_exposer.def( 
                "encodeBase64"
                , encodeBase64_function_type( &CryptManager_wrapper::encodeBase64_f9218abbac278d5cd6937915e06bd355 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("encoded") ) );
        
        }
        { //::osiris::CryptManager::encodeBase64
        
            typedef boost::python::object ( *encodeBase64_function_type )( ::osiris::CryptManager &,void const *,::size_t,::std::string & );
            
            CryptManager_exposer.def( 
                "encodeBase64"
                , encodeBase64_function_type( &CryptManager_wrapper::encodeBase64_38ee4184ffeb0a19a7589a170ccc1d42 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("encoded") ) );
        
        }
        { //::osiris::CryptManager::decodeBase64
        
            typedef boost::python::object ( *decodeBase64_function_type )( ::osiris::CryptManager &,::std::string const &,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "decodeBase64"
                , decodeBase64_function_type( &CryptManager_wrapper::decodeBase64 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("input"), ::boost::python::arg("output") ) );
        
        }
        { //::osiris::CryptManager::encodeHex
        
            typedef boost::python::object ( *encodeHex_function_type )( ::osiris::CryptManager &,void const *,::size_t,::osiris::String & );
            
            CryptManager_exposer.def( 
                "encodeHex"
                , encodeHex_function_type( &CryptManager_wrapper::encodeHex_7b8750fe1349c168dd19acc78f4097a9 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("encoded") ) );
        
        }
        { //::osiris::CryptManager::encodeHex
        
            typedef boost::python::object ( *encodeHex_function_type )( ::osiris::CryptManager &,void const *,::size_t,::std::string & );
            
            CryptManager_exposer.def( 
                "encodeHex"
                , encodeHex_function_type( &CryptManager_wrapper::encodeHex_58e8799e61ba13989814002e9750ba61 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size"), ::boost::python::arg("encoded") ) );
        
        }
        { //::osiris::CryptManager::decodeHex
        
            typedef boost::python::object ( *decodeHex_function_type )( ::osiris::CryptManager &,::std::string const &,::osiris::Buffer & );
            
            CryptManager_exposer.def( 
                "decodeHex"
                , decodeHex_function_type( &CryptManager_wrapper::decodeHex )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("encoded"), ::boost::python::arg("decoded") ) );
        
        }
        { //::osiris::CryptManager::randomBlock
        
            typedef void ( *randomBlock_function_type )( ::osiris::CryptManager const &,void *,::size_t );
            
            CryptManager_exposer.def( 
                "randomBlock"
                , randomBlock_function_type( &CryptManager_wrapper::randomBlock )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::CryptManager::detectCompressor
        
            typedef boost::python::object ( *detectCompressor_function_type )( ::osiris::CryptManager &,::boost::shared_ptr<osiris::IStream> );
            
            CryptManager_exposer.def( 
                "detectCompressor"
                , detectCompressor_function_type( &CryptManager_wrapper::detectCompressor_5ce6eb82fa1ac7c37571973dbaba8ee7 )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("stream") ) );
        
        }
        CryptManager_exposer.def_readonly( "MD5_DIGESTSIZE", ::osiris::CryptManager::MD5_DIGESTSIZE );
        CryptManager_exposer.def_readonly( "MD5_HEX_DIGESTSIZE", ::osiris::CryptManager::MD5_HEX_DIGESTSIZE );
        CryptManager_exposer.def_readonly( "SHA256_DIGESTSIZE", ::osiris::CryptManager::SHA256_DIGESTSIZE );
        CryptManager_exposer.def_readonly( "SHA256_HEX_DIGESTSIZE", ::osiris::CryptManager::SHA256_HEX_DIGESTSIZE );
        CryptManager_exposer.def_readonly( "SHA512_DIGESTSIZE", ::osiris::CryptManager::SHA512_DIGESTSIZE );
        CryptManager_exposer.def_readonly( "SHA512_HEX_DIGESTSIZE", ::osiris::CryptManager::SHA512_HEX_DIGESTSIZE );
        CryptManager_exposer.def_readonly( "SHA_DIGESTSIZE", ::osiris::CryptManager::SHA_DIGESTSIZE );
        CryptManager_exposer.def_readonly( "SHA_HEX_DIGESTSIZE", ::osiris::CryptManager::SHA_HEX_DIGESTSIZE );
        { //property "randomPool"[fget=::osiris::CryptManager::getRandomPool]
        
            typedef ::osiris::LockPtr<CryptoPP::AutoSeededRandomPool,boost::recursive_mutex,boost::unique_lock<boost::recursive_mutex> > ( ::osiris::CryptManager::*fget )(  ) const;
            
            CryptManager_exposer.add_property( 
                "randomPool"
                , fget( &::osiris::CryptManager::getRandomPool )
                , "get property, built on top of \"osiris::LockPtr<CryptoPP::AutoSeededRandomPool,boost::recursive_mutex,boost::unique_lock<boost::recursive_mutex> > osiris::CryptManager::getRandomPool() const [member function]\"" );
        
        }
    }

}
