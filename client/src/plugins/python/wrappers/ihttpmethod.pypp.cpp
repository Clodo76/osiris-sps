// This file has been generated by Py++.

#include "stdafx.h"
#include "pypluspluscommon.h"
#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "ihttpmethod.h"
#include "httpcontent.h"
#include "httpdata.h"
#include "httpresponse.h"
#include "httprequest.h"
#include "ihttpmethod.pypp.hpp"

namespace bp = boost::python;

struct IHttpMethod_wrapper : ::osiris::IHttpMethod, ::osiris::PythonWrapper< ::osiris::IHttpMethod > {

    IHttpMethod_wrapper( )
    : ::osiris::IHttpMethod( )
      , ::osiris::PythonWrapper< ::osiris::IHttpMethod >(){
        // nullptr constructor
    
    }

    static boost::python::object getContent( ::osiris::IHttpMethod const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::boost::shared_ptr<osiris::HttpContent> result = inst.getContent();
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object getStatus( ::osiris::IHttpMethod const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::IHttpMethod::MethodStatus result = inst.getStatus();
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object getRawMethod( ::osiris::IHttpMethod const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::std::string const & result = inst.getRawMethod();
        __pythreadSaver.restore();
        typedef bp::return_value_policy< bp::copy_const_reference > call_policies_t;
        return boost::python::object( pyplusplus::call_policies::make_object< call_policies_t, ::std::string const & >( result ) );
    }

    static boost::python::object getRawParams( ::osiris::IHttpMethod const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::boost::unordered::unordered_multimap<std::string, std::string, boost::hash<std::string>, std::equal_to<std::string>, osiris::StdAllocator<std::pair<std::string const, std::string>, osiris::SysAllocator<std::pair<std::string const, std::string> > > > const & result = inst.getRawParams();
        __pythreadSaver.restore();
        typedef bp::return_value_policy< bp::copy_const_reference > call_policies_t;
        return boost::python::object( pyplusplus::call_policies::make_object< call_policies_t, ::boost::unordered::unordered_multimap<std::string, std::string, boost::hash<std::string>, std::equal_to<std::string>, osiris::StdAllocator<std::pair<std::string const, std::string>, osiris::SysAllocator<std::pair<std::string const, std::string> > > > const & >( result ) );
    }

    static boost::python::object serialize( ::osiris::IHttpMethod const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::boost::shared_ptr<osiris::HttpData> result = inst.serialize();
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object writeData( ::osiris::IHttpMethod & inst, void const * data, ::osiris::uint32 size ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::IHttpMethod::MethodStatus result = inst.writeData(data, size);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    virtual ::boost::shared_ptr< osiris::HttpData > createContent(  ) const {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_createContent = this->get_override( "createContent" ) )
            return func_createContent(  );
        else{
            __pystate.leave();
            return this->::osiris::IHttpMethod::createContent(  );
        }
    }
    
    virtual ::boost::shared_ptr< osiris::HttpData > default_createContent(  ) const {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::IHttpMethod::createContent( );
    }

    virtual bool parseParam( ::std::string const & paramName, ::std::string const & paramValue ){
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_parseParam = this->get_override( "parseParam" ) )
            return func_parseParam( paramName, paramValue );
        else{
            __pystate.leave();
            return this->::osiris::IHttpMethod::parseParam( paramName, paramValue );
        }
    }
    
    virtual bool default_parseParam( ::std::string const & paramName, ::std::string const & paramValue ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::IHttpMethod::parseParam( paramName, paramValue );
    }

    virtual bool parseContent(  ){
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_parseContent = this->get_override( "parseContent" ) )
            return func_parseContent(  );
        else{
            __pystate.leave();
            return this->::osiris::IHttpMethod::parseContent(  );
        }
    }
    
    virtual bool default_parseContent(  ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::IHttpMethod::parseContent( );
    }

    virtual ::boost::shared_ptr< osiris::HttpData > createHeader( ::boost::shared_ptr< osiris::HttpData > content ) const {
        ::osiris::PythonState __pystate(getPythonThreadState());
        ::osiris::PythonOverride func_createHeader = this->get_override( "createHeader" );
        return func_createHeader( content );
    }

    static boost::python::object getRawHeaders( ::osiris::IHttpMethod const & inst, bool terminator ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::std::string result = inst.getRawHeaders(terminator);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object getRawParam( ::osiris::IHttpMethod const & inst, ::std::string const & param ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::std::string const & result = inst.getRawParam(param);
        __pythreadSaver.restore();
        typedef bp::return_value_policy< bp::copy_const_reference > call_policies_t;
        return boost::python::object( pyplusplus::call_policies::make_object< call_policies_t, ::std::string const & >( result ) );
    }

    virtual bool parseHeaders( ::std::string const & headers ){
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_parseHeaders = this->get_override( "parseHeaders" ) )
            return func_parseHeaders( headers );
        else{
            __pystate.leave();
            return this->::osiris::IHttpMethod::parseHeaders( headers );
        }
    }
    
    virtual bool default_parseHeaders( ::std::string const & headers ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::IHttpMethod::parseHeaders( headers );
    }

    virtual bool parseMethod( ::std::string const & header ){
        ::osiris::PythonState __pystate(getPythonThreadState());
        ::osiris::PythonOverride func_parseMethod = this->get_override( "parseMethod" );
        return func_parseMethod( header );
    }

};

void register_IHttpMethod_class(){

    { //::osiris::IHttpMethod
        typedef ::boost::python::class_< IHttpMethod_wrapper, ::boost::noncopyable > IHttpMethod_exposer_t;
        IHttpMethod_exposer_t IHttpMethod_exposer = IHttpMethod_exposer_t( "IHttpMethod", ::boost::python::no_init );
        ::boost::python::scope IHttpMethod_scope( IHttpMethod_exposer );
        ::boost::python::enum_< ::osiris::IHttpMethod::MethodStatus>("MethodStatus")
            .value("statusWaitingHeader", ::osiris::IHttpMethod::statusWaitingHeader)
            .value("statusWaitingContent", ::osiris::IHttpMethod::statusWaitingContent)
            .value("statusCompleted", ::osiris::IHttpMethod::statusCompleted)
            .value("statusError", ::osiris::IHttpMethod::statusError)
            .export_values()
            ;
        IHttpMethod_exposer.def( ::boost::python::init< >() );
        { //::osiris::IHttpMethod::getContent
        
            typedef boost::python::object ( *getContent_function_type )( ::osiris::IHttpMethod const & );
            
            IHttpMethod_exposer.def( 
                "getContent"
                , getContent_function_type( &IHttpMethod_wrapper::getContent ) );
        
        }
        { //::osiris::IHttpMethod::getStatus
        
            typedef boost::python::object ( *getStatus_function_type )( ::osiris::IHttpMethod const & );
            
            IHttpMethod_exposer.def( 
                "getStatus"
                , getStatus_function_type( &IHttpMethod_wrapper::getStatus ) );
        
        }
        { //::osiris::IHttpMethod::getRawMethod
        
            typedef boost::python::object ( *getRawMethod_function_type )( ::osiris::IHttpMethod const & );
            
            IHttpMethod_exposer.def( 
                "getRawMethod"
                , getRawMethod_function_type( &IHttpMethod_wrapper::getRawMethod ) );
        
        }
        { //::osiris::IHttpMethod::getRawParams
        
            typedef boost::python::object ( *getRawParams_function_type )( ::osiris::IHttpMethod const & );
            
            IHttpMethod_exposer.def( 
                "getRawParams"
                , getRawParams_function_type( &IHttpMethod_wrapper::getRawParams ) );
        
        }
        { //::osiris::IHttpMethod::serialize
        
            typedef boost::python::object ( *serialize_function_type )( ::osiris::IHttpMethod const & );
            
            IHttpMethod_exposer.def( 
                "serialize"
                , serialize_function_type( &IHttpMethod_wrapper::serialize ) );
        
        }
        { //::osiris::IHttpMethod::writeData
        
            typedef boost::python::object ( *writeData_function_type )( ::osiris::IHttpMethod &,void const *,::osiris::uint32 );
            
            IHttpMethod_exposer.def( 
                "writeData"
                , writeData_function_type( &IHttpMethod_wrapper::writeData )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("data"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::IHttpMethod::createContent
        
            typedef ::boost::shared_ptr< osiris::HttpData > ( IHttpMethod_wrapper::*createContent_function_type )(  ) const;
            
            IHttpMethod_exposer.def( 
                "createContent"
                , createContent_function_type( &IHttpMethod_wrapper::default_createContent ) );
        
        }
        { //::osiris::IHttpMethod::parseParam
        
            typedef bool ( IHttpMethod_wrapper::*parseParam_function_type )( ::std::string const &,::std::string const & ) ;
            
            IHttpMethod_exposer.def( 
                "parseParam"
                , parseParam_function_type( &IHttpMethod_wrapper::default_parseParam )
                , ( ::boost::python::arg("paramName"), ::boost::python::arg("paramValue") ) );
        
        }
        { //::osiris::IHttpMethod::parseContent
        
            typedef bool ( IHttpMethod_wrapper::*parseContent_function_type )(  ) ;
            
            IHttpMethod_exposer.def( 
                "parseContent"
                , parseContent_function_type( &IHttpMethod_wrapper::default_parseContent ) );
        
        }
        { //::osiris::IHttpMethod::createHeader
        
            typedef ::boost::shared_ptr< osiris::HttpData > ( IHttpMethod_wrapper::*createHeader_function_type )( ::boost::shared_ptr< osiris::HttpData > ) const;
            
            IHttpMethod_exposer.def( 
                "createHeader"
                , createHeader_function_type( &IHttpMethod_wrapper::createHeader )
                , ( ::boost::python::arg("content") ) );
        
        }
        { //::osiris::IHttpMethod::getRawHeaders
        
            typedef boost::python::object ( *getRawHeaders_function_type )( ::osiris::IHttpMethod const &,bool );
            
            IHttpMethod_exposer.def( 
                "getRawHeaders"
                , getRawHeaders_function_type( &IHttpMethod_wrapper::getRawHeaders )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("terminator") ) );
        
        }
        { //::osiris::IHttpMethod::getRawParam
        
            typedef boost::python::object ( *getRawParam_function_type )( ::osiris::IHttpMethod const &,::std::string const & );
            
            IHttpMethod_exposer.def( 
                "getRawParam"
                , getRawParam_function_type( &IHttpMethod_wrapper::getRawParam )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("param") ) );
        
        }
        { //::osiris::IHttpMethod::parseHeaders
        
            typedef bool ( IHttpMethod_wrapper::*parseHeaders_function_type )( ::std::string const & ) ;
            
            IHttpMethod_exposer.def( 
                "parseHeaders"
                , parseHeaders_function_type( &IHttpMethod_wrapper::default_parseHeaders )
                , ( ::boost::python::arg("headers") ) );
        
        }
        { //::osiris::IHttpMethod::parseMethod
        
            typedef bool ( IHttpMethod_wrapper::*parseMethod_function_type )( ::std::string const & ) ;
            
            IHttpMethod_exposer.def( 
                "parseMethod"
                , parseMethod_function_type( &IHttpMethod_wrapper::parseMethod )
                , ( ::boost::python::arg("header") ) );
        
        }
        { //property "content"[fget=::osiris::IHttpMethod::getContent]
        
            typedef ::boost::shared_ptr<osiris::HttpContent> ( ::osiris::IHttpMethod::*fget )(  ) const;
            
            IHttpMethod_exposer.add_property( 
                "content"
                , fget( &::osiris::IHttpMethod::getContent )
                , "get property, built on top of \"boost::shared_ptr<osiris::HttpContent> osiris::IHttpMethod::getContent() const [member function]\"" );
        
        }
        { //property "status"[fget=::osiris::IHttpMethod::getStatus]
        
            typedef ::osiris::IHttpMethod::MethodStatus ( ::osiris::IHttpMethod::*fget )(  ) const;
            
            IHttpMethod_exposer.add_property( 
                "status"
                , fget( &::osiris::IHttpMethod::getStatus )
                , "get property, built on top of \"osiris::IHttpMethod::MethodStatus osiris::IHttpMethod::getStatus() const [member function]\"" );
        
        }
        { //property "rawMethod"[fget=::osiris::IHttpMethod::getRawMethod]
        
            typedef ::std::string const & ( ::osiris::IHttpMethod::*fget )(  ) const;
            
            IHttpMethod_exposer.add_property( 
                "rawMethod"
                , ::boost::python::make_function( 
                      fget( &::osiris::IHttpMethod::getRawMethod )
                    , bp::return_value_policy< bp::copy_const_reference >() ) 
                , "get property, built on top of \"std::string const & osiris::IHttpMethod::getRawMethod() const [member function]\"" );
        
        }
        { //property "rawParams"[fget=::osiris::IHttpMethod::getRawParams]
        
            typedef ::boost::unordered::unordered_multimap<std::string, std::string, boost::hash<std::string>, std::equal_to<std::string>, osiris::StdAllocator<std::pair<std::string const, std::string>, osiris::SysAllocator<std::pair<std::string const, std::string> > > > const & ( ::osiris::IHttpMethod::*fget )(  ) const;
            
            IHttpMethod_exposer.add_property( 
                "rawParams"
                , ::boost::python::make_function( 
                      fget( &::osiris::IHttpMethod::getRawParams )
                    , bp::return_value_policy< bp::copy_const_reference >() ) 
                , "get property, built on top of \"boost::unordered::unordered_multimap<std::string, std::string, boost::hash<std::string>, std::equal_to<std::string>, osiris::StdAllocator<std::pair<std::string const, std::string>, osiris::SysAllocator<std::pair<std::string const, std::string> > > > const & osiris::IHttpMethod::getRawParams() const [member function]\"" );
        
        }
    }

}
