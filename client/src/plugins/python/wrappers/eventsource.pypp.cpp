// This file has been generated by Py++.

#include "stdafx.h"
#include "pypluspluscommon.h"
#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "eventsource.h"
#include "ievent.h"
#include "eventsource.pypp.hpp"

namespace bp = boost::python;

struct EventSource_wrapper : ::osiris::EventSource, ::osiris::PythonWrapper< ::osiris::EventSource > {

    EventSource_wrapper( )
    : ::osiris::EventSource( )
      , ::osiris::PythonWrapper< ::osiris::EventSource >(){
        // nullptr constructor
    
    }

    static boost::python::object empty( ::osiris::EventSource const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.empty();
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static void clear( ::osiris::EventSource & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        inst.clear();
        __pythreadSaver.restore();
    }

    virtual void fire( ::osiris::IEvent * e=(nullptr) ) {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_fire = this->get_override( "fire" ) )
            func_fire( boost::python::ptr(e) );
        else{
            __pystate.leave();
            this->::osiris::EventSource::fire( boost::python::ptr(e) );
        }
    }
    
    void default_fire( ::osiris::IEvent * e=(nullptr) ) {
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::osiris::EventSource::fire( boost::python::ptr(e) );
    }

    static boost::python::object connect_3da2b6ebdfc65e81570ac07a7fff587e( ::osiris::EventSource & inst, ::boost::shared_ptr< osiris::IEventCallback > callback ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::boost::shared_ptr<osiris::IEventCallback> result = inst.connect(callback);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static boost::python::object connect_089e5f8b46883daf07db9e4eca92c4fa( ::osiris::EventSource & inst, ::boost::shared_ptr< osiris::IEventCallback > const & callback ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::boost::shared_ptr<osiris::IEventCallback> result = inst.connect(callback);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    static void disconnect( ::osiris::EventSource & inst, ::boost::shared_ptr< osiris::IEventCallback > callback ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        inst.disconnect(callback);
        __pythreadSaver.restore();
    }

};

void register_EventSource_class(){

    { //::osiris::EventSource
        typedef ::boost::python::class_< EventSource_wrapper, ::boost::noncopyable > EventSource_exposer_t;
        EventSource_exposer_t EventSource_exposer = EventSource_exposer_t( "EventSource", ::boost::python::no_init );
        ::boost::python::scope EventSource_scope( EventSource_exposer );
        EventSource_exposer.def( ::boost::python::init< >() );
        { //::osiris::EventSource::empty
        
            typedef boost::python::object ( *empty_function_type )( ::osiris::EventSource const & );
            
            EventSource_exposer.def( 
                "empty"
                , empty_function_type( &EventSource_wrapper::empty ) );
        
        }
        { //::osiris::EventSource::clear
        
            typedef void ( *clear_function_type )( ::osiris::EventSource & );
            
            EventSource_exposer.def( 
                "clear"
                , clear_function_type( &EventSource_wrapper::clear ) );
        
        }
        { //::osiris::EventSource::fire
        
            typedef void ( ::osiris::EventSource::*fire_function_type )( ::osiris::IEvent * ) ;
            typedef void ( EventSource_wrapper::*default_fire_function_type )( ::osiris::IEvent * ) ;
            
            EventSource_exposer.def( 
                "fire"
                , fire_function_type(&::osiris::EventSource::fire)
                , default_fire_function_type(&EventSource_wrapper::default_fire)
                , ( ::boost::python::arg("e")=(nullptr) ) );
        
        }
        { //::osiris::EventSource::connect
        
            typedef boost::python::object ( *connect_function_type )( ::osiris::EventSource &,::boost::shared_ptr<osiris::IEventCallback> );
            
            EventSource_exposer.def( 
                "connect"
                , connect_function_type( &EventSource_wrapper::connect_3da2b6ebdfc65e81570ac07a7fff587e )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("callback") ) );
        
        }
        { //::osiris::EventSource::connect
        
            typedef boost::python::object ( *connect_function_type )( ::osiris::EventSource &,::boost::shared_ptr<osiris::IEventCallback> const & );
            
            EventSource_exposer.def( 
                "connect"
                , connect_function_type( &EventSource_wrapper::connect_089e5f8b46883daf07db9e4eca92c4fa )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("callback") ) );
        
        }
        { //::osiris::EventSource::disconnect
        
            typedef void ( *disconnect_function_type )( ::osiris::EventSource &,::boost::shared_ptr<osiris::IEventCallback> );
            
            EventSource_exposer.def( 
                "disconnect"
                , disconnect_function_type( &EventSource_wrapper::disconnect )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("callback") ) );
        
        }
        ::boost::python::register_ptr_to_python< boost::shared_ptr< ::osiris::EventSource > >();
        ::boost::python::implicitly_convertible< boost::shared_ptr< ::osiris::EventSource >, boost::shared_ptr< ::osiris::enable_this_ptr< osiris::EventSource > > >();
        ::boost::python::implicitly_convertible< boost::shared_ptr< ::osiris::EventSource >, boost::shared_ptr< ::boost::noncopyable_::noncopyable > >();
        ::boost::python::implicitly_convertible< boost::shared_ptr< ::osiris::EventSource >, boost::shared_ptr< ::osiris::Object > >();
    }

}
