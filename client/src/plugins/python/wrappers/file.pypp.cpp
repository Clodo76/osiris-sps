// This file has been generated by Py++.

#include "stdafx.h"
#include "pypluspluscommon.h"
#include "boost/python.hpp"
#include "__call_policies.pypp.hpp"
#include "file.h"
#include "textfile.h"
#include "file.pypp.hpp"

namespace bp = boost::python;

struct File_wrapper : ::osiris::File, ::osiris::PythonWrapper< ::osiris::File > {

    File_wrapper( )
    : ::osiris::File( )
      , ::osiris::PythonWrapper< ::osiris::File >(){
        // nullptr constructor
    
    }

    File_wrapper(::osiris::String const & filename, ::osiris::uint32 flags )
    : ::osiris::File( boost::ref(filename), flags )
      , ::osiris::PythonWrapper< ::osiris::File >(){
        // constructor
    
    }

    static boost::python::object getHandle( ::osiris::File const & inst ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        ::FILE * result = inst.getHandle();
        __pythreadSaver.restore();
        typedef bp::return_value_policy< bp::reference_existing_object > call_policies_t;
        return boost::python::object( pyplusplus::call_policies::make_object< call_policies_t, ::FILE * >( result ) );
    }

    virtual bool open( ::osiris::String const & filename, ::osiris::uint32 flags ) {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_open = this->get_override( "open" ) )
            return func_open( boost::ref(filename), flags );
        else{
            __pystate.leave();
            return this->::osiris::File::open( boost::ref(filename), flags );
        }
    }
    
    bool default_open( ::osiris::String const & filename, ::osiris::uint32 flags ) {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::open( boost::ref(filename), flags );
    }

    virtual bool is_open(  ) const  {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_is_open = this->get_override( "is_open" ) )
            return func_is_open(  );
        else{
            __pystate.leave();
            return this->::osiris::File::is_open(  );
        }
    }
    
    bool default_is_open(  ) const  {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::is_open( );
    }

    virtual bool close(  ) {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_close = this->get_override( "close" ) )
            return func_close(  );
        else{
            __pystate.leave();
            return this->::osiris::File::close(  );
        }
    }
    
    bool default_close(  ) {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::close( );
    }

    virtual ::osiris::uint32 read( void * v, ::osiris::uint32 size ) const  {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_read = this->get_override( "read" ) )
            return func_read( v, size );
        else{
            __pystate.leave();
            return this->::osiris::File::read( v, size );
        }
    }
    
    ::osiris::uint32 default_read( void * v, ::osiris::uint32 size ) const  {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::read( v, size );
    }

    virtual ::osiris::uint32 write( void const * v, ::osiris::uint32 size ) {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_write = this->get_override( "write" ) )
            return func_write( v, size );
        else{
            __pystate.leave();
            return this->::osiris::File::write( v, size );
        }
    }
    
    ::osiris::uint32 default_write( void const * v, ::osiris::uint32 size ) {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::write( v, size );
    }

    virtual bool seek( ::osiris::uint64 offset, ::osiris::SeekPosition from ) const  {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_seek = this->get_override( "seek" ) )
            return func_seek( offset, from );
        else{
            __pystate.leave();
            return this->::osiris::File::seek( offset, from );
        }
    }
    
    bool default_seek( ::osiris::uint64 offset, ::osiris::SeekPosition from ) const  {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::seek( offset, from );
    }

    virtual ::osiris::uint64 position(  ) const  {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_position = this->get_override( "position" ) )
            return func_position(  );
        else{
            __pystate.leave();
            return this->::osiris::File::position(  );
        }
    }
    
    ::osiris::uint64 default_position(  ) const  {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::position( );
    }

    virtual ::osiris::uint64 size(  ) const  {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_size = this->get_override( "size" ) )
            return func_size(  );
        else{
            __pystate.leave();
            return this->::osiris::File::size(  );
        }
    }
    
    ::osiris::uint64 default_size(  ) const  {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::size( );
    }

    virtual bool flush(  ) {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_flush = this->get_override( "flush" ) )
            return func_flush(  );
        else{
            __pystate.leave();
            return this->::osiris::File::flush(  );
        }
    }
    
    bool default_flush(  ) {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::flush( );
    }

    virtual bool eof(  ) const  {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_eof = this->get_override( "eof" ) )
            return func_eof(  );
        else{
            __pystate.leave();
            return this->::osiris::File::eof(  );
        }
    }
    
    bool default_eof(  ) const  {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::File::eof( );
    }

    static boost::python::object getStats( ::osiris::File const & inst, ::boost::posix_time::ptime * timeCreation, ::boost::posix_time::ptime * timeLastModify=(nullptr), ::boost::posix_time::ptime * timeLastAccess=(nullptr) ){
        ::osiris::PythonThreadSaver __pythreadSaver;
        bool result = inst.getStats(timeCreation, timeLastModify, timeLastAccess);
        __pythreadSaver.restore();
        return boost::python::object( result );
    }

    virtual ::osiris::uint32 peek( void * v, ::osiris::uint32 size ) const  {
        ::osiris::PythonState __pystate(getPythonThreadState());
        if( ::osiris::PythonOverride func_peek = this->get_override( "peek" ) )
            return func_peek( v, size );
        else{
            __pystate.leave();
            return this->::osiris::IStream::peek( v, size );
        }
    }
    
    ::osiris::uint32 default_peek( void * v, ::osiris::uint32 size ) const  {
        ::osiris::PythonThreadSaver __pythreadSaver;
        return ::osiris::IStream::peek( v, size );
    }

};

void register_File_class(){

    { //::osiris::File
        typedef ::boost::python::class_< File_wrapper, ::boost::python::bases< ::osiris::IStream >, ::boost::noncopyable > File_exposer_t;
        File_exposer_t File_exposer = File_exposer_t( "File", ::boost::python::init< >() );
        ::boost::python::scope File_scope( File_exposer );
        ::boost::python::enum_< ::osiris::File::OpenFlags>("OpenFlags")
            .value("ofRead", ::osiris::File::ofRead)
            .value("ofWrite", ::osiris::File::ofWrite)
            .value("ofReadWrite", ::osiris::File::ofReadWrite)
            .value("ofNoTruncate", ::osiris::File::ofNoTruncate)
            .value("ofBinary", ::osiris::File::ofBinary)
            .value("ofText", ::osiris::File::ofText)
            .export_values()
            ;
        File_exposer.def( ::boost::python::init< ::osiris::String const &, ::osiris::uint32 >(( ::boost::python::arg("filename"), ::boost::python::arg("flags") )) );
        { //::osiris::File::getHandle
        
            typedef boost::python::object ( *getHandle_function_type )( ::osiris::File const & );
            
            File_exposer.def( 
                "getHandle"
                , getHandle_function_type( &File_wrapper::getHandle ) );
        
        }
        { //::osiris::File::open
        
            typedef bool ( ::osiris::File::*open_function_type )( ::osiris::String const &,::osiris::uint32 ) ;
            typedef bool ( File_wrapper::*default_open_function_type )( ::osiris::String const &,::osiris::uint32 ) ;
            
            File_exposer.def( 
                "open"
                , open_function_type(&::osiris::File::open)
                , default_open_function_type(&File_wrapper::default_open)
                , ( ::boost::python::arg("filename"), ::boost::python::arg("flags") ) );
        
        }
        { //::osiris::File::is_open
        
            typedef bool ( ::osiris::File::*is_open_function_type )(  ) const;
            typedef bool ( File_wrapper::*default_is_open_function_type )(  ) const;
            
            File_exposer.def( 
                "is_open"
                , is_open_function_type(&::osiris::File::is_open)
                , default_is_open_function_type(&File_wrapper::default_is_open) );
        
        }
        { //::osiris::File::close
        
            typedef bool ( ::osiris::File::*close_function_type )(  ) ;
            typedef bool ( File_wrapper::*default_close_function_type )(  ) ;
            
            File_exposer.def( 
                "close"
                , close_function_type(&::osiris::File::close)
                , default_close_function_type(&File_wrapper::default_close) );
        
        }
        { //::osiris::File::read
        
            typedef ::osiris::uint32 ( ::osiris::File::*read_function_type )( void *,::osiris::uint32 ) const;
            typedef ::osiris::uint32 ( File_wrapper::*default_read_function_type )( void *,::osiris::uint32 ) const;
            
            File_exposer.def( 
                "read"
                , read_function_type(&::osiris::File::read)
                , default_read_function_type(&File_wrapper::default_read)
                , ( ::boost::python::arg("v"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::File::write
        
            typedef ::osiris::uint32 ( ::osiris::File::*write_function_type )( void const *,::osiris::uint32 ) ;
            typedef ::osiris::uint32 ( File_wrapper::*default_write_function_type )( void const *,::osiris::uint32 ) ;
            
            File_exposer.def( 
                "write"
                , write_function_type(&::osiris::File::write)
                , default_write_function_type(&File_wrapper::default_write)
                , ( ::boost::python::arg("v"), ::boost::python::arg("size") ) );
        
        }
        { //::osiris::File::seek
        
            typedef bool ( ::osiris::File::*seek_function_type )( ::osiris::uint64,::osiris::SeekPosition ) const;
            typedef bool ( File_wrapper::*default_seek_function_type )( ::osiris::uint64,::osiris::SeekPosition ) const;
            
            File_exposer.def( 
                "seek"
                , seek_function_type(&::osiris::File::seek)
                , default_seek_function_type(&File_wrapper::default_seek)
                , ( ::boost::python::arg("offset"), ::boost::python::arg("from") ) );
        
        }
        { //::osiris::File::position
        
            typedef ::osiris::uint64 ( ::osiris::File::*position_function_type )(  ) const;
            typedef ::osiris::uint64 ( File_wrapper::*default_position_function_type )(  ) const;
            
            File_exposer.def( 
                "position"
                , position_function_type(&::osiris::File::position)
                , default_position_function_type(&File_wrapper::default_position) );
        
        }
        { //::osiris::File::size
        
            typedef ::osiris::uint64 ( ::osiris::File::*size_function_type )(  ) const;
            typedef ::osiris::uint64 ( File_wrapper::*default_size_function_type )(  ) const;
            
            File_exposer.def( 
                "size"
                , size_function_type(&::osiris::File::size)
                , default_size_function_type(&File_wrapper::default_size) );
        
        }
        { //::osiris::File::flush
        
            typedef bool ( ::osiris::File::*flush_function_type )(  ) ;
            typedef bool ( File_wrapper::*default_flush_function_type )(  ) ;
            
            File_exposer.def( 
                "flush"
                , flush_function_type(&::osiris::File::flush)
                , default_flush_function_type(&File_wrapper::default_flush) );
        
        }
        { //::osiris::File::eof
        
            typedef bool ( ::osiris::File::*eof_function_type )(  ) const;
            typedef bool ( File_wrapper::*default_eof_function_type )(  ) const;
            
            File_exposer.def( 
                "eof"
                , eof_function_type(&::osiris::File::eof)
                , default_eof_function_type(&File_wrapper::default_eof) );
        
        }
        { //::osiris::File::getStats
        
            typedef boost::python::object ( *getStats_function_type )( ::osiris::File const &,::boost::posix_time::ptime *,::boost::posix_time::ptime *,::boost::posix_time::ptime * );
            
            File_exposer.def( 
                "getStats"
                , getStats_function_type( &File_wrapper::getStats )
                , ( ::boost::python::arg("inst"), ::boost::python::arg("timeCreation"), ::boost::python::arg("timeLastModify")=(nullptr), ::boost::python::arg("timeLastAccess")=(nullptr) ) );
        
        }
        { //::osiris::IStream::peek
        
            typedef ::osiris::uint32 ( ::osiris::IStream::*peek_function_type )( void *,::osiris::uint32 ) const;
            typedef ::osiris::uint32 ( File_wrapper::*default_peek_function_type )( void *,::osiris::uint32 ) const;
            
            File_exposer.def( 
                "peek"
                , peek_function_type(&::osiris::IStream::peek)
                , default_peek_function_type(&File_wrapper::default_peek)
                , ( ::boost::python::arg("v"), ::boost::python::arg("size") ) );
        
        }
        { //property "handle"[fget=::osiris::File::getHandle]
        
            typedef ::FILE * ( ::osiris::File::*fget )(  ) const;
            
            File_exposer.add_property( 
                "handle"
                , ::boost::python::make_function( 
                      fget( &::osiris::File::getHandle )
                    , bp::return_value_policy< bp::reference_existing_object >() ) 
                , "get property, built on top of \"FILE * osiris::File::getHandle() const [member function]\"" );
        
        }
        ::boost::python::register_ptr_to_python< boost::shared_ptr< ::osiris::File > >();
        ::boost::python::implicitly_convertible< boost::shared_ptr< ::osiris::File >, boost::shared_ptr< ::boost::noncopyable_::noncopyable > >();
        ::boost::python::implicitly_convertible< boost::shared_ptr< ::osiris::File >, boost::shared_ptr< ::osiris::Object > >();
        ::boost::python::implicitly_convertible< boost::shared_ptr< ::osiris::TextFile >, boost::shared_ptr< ::osiris::File > >();
    }

}
